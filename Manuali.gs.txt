function AIUTO_RAPIDO() {
  const ui = SpreadsheetApp.getUi();

  const msg =
`üì¶ AIUTO RAPIDO ‚Äî USO QUOTIDIANO
================================

‚úÖ 1) DOVE SI LAVORA
-------------------
‚Ä¢ Il lavoro di tutti i giorni si fa in: "Settimana Attiva"
‚Ä¢ Ogni giorno ha 2 colonne:
  - Colonna NOME fornitore
  - Colonna CHECKBOX "Partito" (a fianco)
‚Ä¢ Usa SOLO le righe da 3 a 20.
‚û°Ô∏è Le righe sotto sono bloccate automaticamente.

‚úÖ 2) INSERIRE UN FORNITORE
--------------------------
‚Ä¢ Scrivi il nome del fornitore nella colonna NOME del giorno giusto.
‚û°Ô∏è La checkbox viene creata automaticamente solo se c‚Äô√® un nome.

‚úÖ 3) FORNITORE ‚ÄúNON IN PARTENZA‚Äù
--------------------------------
‚Ä¢ Se un fornitore NON deve partire, scrivilo iniziando con:
  - "- " (trattino + spazio)
Esempio: "- RHIAG"
‚û°Ô∏è In quel caso la checkbox NON √® spuntabile (√® bloccata apposta).

‚úÖ 4) SPUNTARE ‚ÄúPARTITO‚Äù
-----------------------
‚Ä¢ Spunta la checkbox SOLO quando il fornitore √® davvero partito.
‚Ä¢ Non √® possibile spuntare giorni futuri.
‚Ä¢ Se togli una spunta gi√† data, viene chiesta conferma.

‚ö†Ô∏è 5) MODIFICHE SU GIORNI PASSATI
---------------------------------
‚Ä¢ Se scrivi o modifichi un giorno PASSATO, compare sempre un popup.
‚û°Ô∏è Serve per evitare modifiche accidentali nello storico.

‚úÖ 6) COSA VEDERE A COLPO D‚ÄôOCCHIO
---------------------------------
‚Ä¢ Il giorno corrente √® evidenziato.
‚Ä¢ I giorni ‚ÄúCHIUSI‚Äù (da Impostazioni) sono marcati.
‚Ä¢ In alto a destra:
  - N3 = STATO SISTEMA
  - N4 = AZIONE DA FARE (se serve)
  - N5 = LINK (solo se necessario)

============================================================
üì¶ GESTIONE SETTIMANA ‚Äî FUNZIONI (MENU PER TUTTI)
============================================================

üëâ CREARE "PROSSIMA SETTIMANA"
-----------------------------
‚Ä¢ Vai su "Settimana Attiva"
‚Ä¢ SPUNTA la checkbox in N2
‚û°Ô∏è Risultato:
   - viene creato il foglio "Prossima settimana"
   - N1 cambia stato (‚úÖ pronta)
   - N5 mostra il link per aprirla
   - N2 resta spuntata finch√© Prossima settimana esiste

üì¶ ARCHIVIARE LA SETTIMANA
--------------------------
Menu: üì¶ Gestione Settimana ‚Üí üì¶ Archivia settimana
‚û°Ô∏è Risultato:
   - salva nello storico (solo per controllo)
   - aggiorna la Settimana Attiva
   - Prossima settimana viene eliminata (se presente)
   - stato sistema torna OK

üóëÔ∏è ELIMINARE "PROSSIMA SETTIMANA" (FORZATO)
-------------------------------------------
Menu: üì¶ Gestione Settimana ‚Üí üß® Elimina Prossima settimana (FORZATO)
‚û°Ô∏è Risultato:
   - foglio eliminato
   - N1 e N2 tornano allo stato base
   - eventuali link spariscono

üë§ LOG OPERATIVO - UTENTE
-------------------------
Menu: üì¶ Gestione Settimana ‚Üí üë§ Imposta mio nome (Log)
‚Ä¢ Serve per identificare chi fa le operazioni.
‚Ä¢ Usalo se nel Log compare "Utente non rilevabile".

ü©∫ HEALTHCHECK VISIVO
---------------------
Menu: üì¶ Gestione Settimana ‚Üí ü©∫ Healthcheck visivo
‚Ä¢ Ripara automaticamente:
  - intestazioni
  - evidenze del giorno
  - stato Prossima settimana
‚Ä¢ Il controllo viene fatto anche in automatico.

------------------------------------------------------------
üîß NOTA
------------------------------------------------------------
‚Ä¢ Esiste anche un menu "üîß Tecnico" con funzioni di manutenzione.
‚Ä¢ Di norma NON serve per il lavoro quotidiano.
`;

  ui.alert("üì¶ Aiuto rapido", msg, ui.ButtonSet.OK);
}

function HEALTHCHECK_VISIVO_MANUALE() {
  HEALTHCHECK_VISIVO();
  SpreadsheetApp.getActive().toast("Healthcheck visivo completato ‚úÖ", "Gestione Settimana", 4);
}

function _hcWriteLastRun_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName("Settimana Attiva");
  if (!sh) return;

  const tz = Session.getScriptTimeZone();
  const now = new Date();
  const stamp = Utilities.formatDate(now, tz, "dd/MM HH:mm");

  const cell = sh.getRange("N19");
  cell
    .setValue(`üïí Ultimo controllo: ${stamp}`)
    .setFontSize(10)              // ‚úÖ FONT 10
    .setFontStyle("italic")
    .setFontWeight("normal")
    .setFontColor("#666666")
    .setBackground("#ffffff")
    .setHorizontalAlignment("center")
    .setVerticalAlignment("middle");
}

function _hcUpdateCounters_(hadInterventions) {
  const props = PropertiesService.getDocumentProperties();

  const tz = Session.getScriptTimeZone();
  const todayKey = Utilities.formatDate(new Date(), tz, "yyyy-MM-dd");

  if (props.getProperty("HC_LAST_DAY") !== todayKey) {
    props.setProperty("HC_LAST_DAY", todayKey);
    props.setProperty("HC_TODAY", "0");
  }

  let today = Number(props.getProperty("HC_TODAY") || 0);
  let total = Number(props.getProperty("HC_TOTAL") || 0);

  if (hadInterventions) {
    today++;
    total++;
    props.setProperty("HC_TODAY", String(today));
    props.setProperty("HC_TOTAL", String(total));
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName("Settimana Attiva");
  if (!sh) return;

  const cell = sh.getRange("N20");
  cell
    .setValue(`üìä Interventi oggi: ${today} | Totale: ${total}`)
    .setFontSize(10)              // ‚úÖ FONT 10
    .setFontStyle("italic")
    .setFontWeight("normal")
    .setFontColor("#666666")
    .setBackground("#f3f3f3")
    .setHorizontalAlignment("center")
    .setVerticalAlignment("middle");
}

/****************************************************
 * ONOPEN ROBUSTO: menu subito + healthcheck differito
 ****************************************************/

function onOpen(e) {
  // 1) Menu SEMPRE per primi
  try { BUILD_MENUS_(); } catch (err) {}

  // 2) Pianifica healthcheck differito (non blocca i menu)
  try { _SCHEDULE_HEALTHCHECK_AFTER_OPEN_(); } catch (err) {}
}

/**
 * Crea un trigger "usa e getta" che esegue il healthcheck dopo ~45s.
 * Evita duplicati con una property.
 */
function _SCHEDULE_HEALTHCHECK_AFTER_OPEN_() {
  const props = PropertiesService.getDocumentProperties();
  const key = "HC_DEFERRED_PENDING";
  if (props.getProperty(key) === "1") return; // gi√† pianificato

  // segna pending
  props.setProperty(key, "1");

  // crea trigger una tantum tra 45 secondi
  ScriptApp.newTrigger("_RUN_HEALTHCHECK_DEFERRED_")
    .timeBased()
    .after(45 * 1000)
    .create();
}

/**
 * Esegue healthcheck e poi:
 * - ripristina UI protette
 * - ripara N18/checkbox se necessario
 * - rimuove il trigger che l‚Äôha chiamata
 * - toglie la flag pending
 */
function _RUN_HEALTHCHECK_DEFERRED_() {
  const props = PropertiesService.getDocumentProperties();
  const key = "HC_DEFERRED_PENDING";

  try {
    // Healthcheck principale
    try { HEALTHCHECK_VISIVO(); } catch (e) {}

    // Ripristini UI colonna N
    try { UI_RIPRISTINA_CELLE_N_PROTETTE_(); } catch (e) {}

    // Ripara validazioni checkbox (N18 + tabella) se si sono sporcate
    try { RIPARA_VALIDAZIONI_CHECKBOX_HARD_(); } catch (e) {}

  } finally {
    // clear pending
    try { props.deleteProperty(key); } catch (e) {}

    // autodistrugge i trigger di questa funzione (cos√¨ non si accumulano)
    try {
      const all = ScriptApp.getProjectTriggers();
      for (const t of all) {
        if (t.getHandlerFunction && t.getHandlerFunction() === "_RUN_HEALTHCHECK_DEFERRED_") {
          ScriptApp.deleteTrigger(t);
        }
      }
    } catch (e) {}
  }
}

/****************************************************
 * RIPARAZIONE HARD VALIDAZIONI CHECKBOX
 * - Risolve "Invalid: violates validation rule" su N18
 * - Se per errore la validazione checkbox √® finita in L3 (o altrove),
 *   pulisce A3:L20 e ricostruisce le checkbox coerenti ai nomi.
 ****************************************************/
function RIPARA_VALIDAZIONI_CHECKBOX_HARD_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheets = ["Settimana Attiva", "Prossima settimana"];

  for (const name of sheets) {
    const sh = ss.getSheetByName(name);
    if (!sh) continue;

    // 1) N18: deve essere SOLO checkbox, senza validazioni "strane"
    try {
      const c = sh.getRange("N18");
      c.clearContent();
      c.clearDataValidations();
      c.insertCheckboxes();
      c.setValue(false);
      c.setHorizontalAlignment("center").setVerticalAlignment("middle");
    } catch (e) {}

    // 2) Tabella A3:L20: se una checkbox-validation √® finita in celle sbagliate (es. L3),
    //    puliamo tutte le data validations e ricostruiamo SOLO le checkbox corrette.
    try {
      sh.getRange("A3:L20").clearDataValidations();
      // ricostruisce checkbox e lascia vuote dove nome vuoto
      if (typeof MINI_FIX_FORMAT_TAB_FORNITORI_ === "function") {
        // la tua funzione agisce su entrambe: ok, ma qui siamo gi√† nel loop.
        // Se preferisci, commenta la riga sotto e lascia solo il rebuild manuale.
        MINI_FIX_FORMAT_TAB_FORNITORI_();
      } else {
        _REBUILD_CHECKBOXES_FROM_NAMES_(sh);
      }
    } catch (e) {}
  }
}

/**
 * Fallback se MINI_FIX_FORMAT_TAB_FORNITORI_ non esiste:
 * ricostruisce le checkbox in B/D/F/H/J/L in base ai nomi A/C/E/G/I/K.
 */
function _REBUILD_CHECKBOXES_FROM_NAMES_(sh) {
  const COL_NOMI = [1, 3, 5, 7, 9, 11];
  const COL_CK   = [2, 4, 6, 8, 10, 12];
  const START_ROW = 3;
  const NUM_ROWS = 18; // 3..20

  for (let i = 0; i < COL_NOMI.length; i++) {
    const colNome = COL_NOMI[i];
    const colCk = COL_CK[i];

    const nomi = sh.getRange(START_ROW, colNome, NUM_ROWS, 1).getValues();
    const ckRange = sh.getRange(START_ROW, colCk, NUM_ROWS, 1);
    const ckVals = ckRange.getValues();

    for (let r = 0; r < NUM_ROWS; r++) {
      const rawNome = nomi[r][0];
      const nomeTxt = String(rawNome ?? "").replace(/\u00A0/g, " ").trim();
      const cellCk = sh.getRange(START_ROW + r, colCk);

      if (!nomeTxt) {
        cellCk.clearContent();
        cellCk.clearDataValidations();
        continue;
      }

      cellCk.clearDataValidations();
      cellCk.insertCheckboxes();

      if (typeof _isNoPartenza_ === "function" && _isNoPartenza_(rawNome)) {
        cellCk.setValue(false);
      } else {
        cellCk.setValue(ckVals[r][0] === true);
      }
    }
  }
}

function _TEST_COMPILE_(){ return 1; }