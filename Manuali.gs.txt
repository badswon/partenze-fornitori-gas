function AIUTO_RAPIDO() {
  const ui = SpreadsheetApp.getUi();

  const msg =
`üì¶ AIUTO RAPIDO (USO QUOTIDIANO)

‚úÖ COSA DEVI FARE OGNI GIORNO
1) Lavora SOLO nel foglio: ‚ÄúSettimana Attiva‚Äù
2) Scrivi i fornitori nelle righe da 3 a 20, nel giorno giusto
3) Quando un fornitore √® partito, spunta la casella ‚ÄúPartito‚Äù accanto al suo nome
4) Fine.

------------------------------------------------

üü¶ COME INSERIRE UN FORNITORE (in 10 secondi)
‚Ä¢ Vai al giorno giusto
‚Ä¢ Scrivi il nome del fornitore nella colonna del giorno
‚û°Ô∏è La casella ‚ÄúPartito‚Äù comparir√† da sola accanto al nome

------------------------------------------------

‚òëÔ∏è COME SEGNARE ‚ÄúPARTITO‚Äù
‚Ä¢ Spunta la casella SOLO quando √® davvero partito
‚Ä¢ Se provi a spuntare un giorno futuro, il sistema te lo impedisce (ed √® normale)

------------------------------------------------

üö´ SE UN FORNITORE NON DEVE PARTIRE OGGI
Scrivi il nome cos√¨:
- NOME FORNITORE
(esempio: - RHIAG)

‚û°Ô∏è In questo modo si capisce che oggi NON deve partire.

------------------------------------------------

üü• SE VEDI UN AVVISO ROSSO ‚ÄúSETTIMANA DA ARCHIVIARE‚Äù
Vuol dire che sei in ritardo di una settimana.
Fai cos√¨:

Menu in alto:
üì¶ Gestione Settimana ‚Üí üì¶ Archivia settimana

Poi controlla che il box in alto a destra torni verde ‚úÖ

------------------------------------------------

‚ö†Ô∏è COSE IMPORTANTI (EVITA ERRORI)
‚Ä¢ Non lavorare sotto la riga 20
‚Ä¢ Non incollare ‚Äúblocchi‚Äù di celle: modifica 1 cella alla volta
‚Ä¢ Non cancellare le caselle ‚ÄúPartito‚Äù (se succede, si ricreano da sole)

------------------------------------------------

üÜò SE QUALCOSA SEMBRA STRANO
Menu:
üì¶ Gestione Settimana ‚Üí ü©∫ Healthcheck visivo
(√à un ‚Äúripara tutto‚Äù sicuro)

Fine üôÇ































üòè Se dopo aver letto questo aiuto ancora non sai cosa fare
vuol dire che sei tonto/a come il cazzo in acqua.

üëâ Chiedi a Francesco.
Buccabbeltu! ü§°üòÇ`;

  ui.alert("üì¶ Aiuto rapido", msg, ui.ButtonSet.OK);
}

function HEALTHCHECK_VISIVO_MANUALE() {
  HEALTHCHECK_VISIVO();
  SpreadsheetApp.getActive().toast("Healthcheck visivo completato ‚úÖ", "Gestione Settimana", 4);
}

function _hcWriteLastRun_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName("Settimana Attiva");
  if (!sh) return;

  const tz = Session.getScriptTimeZone();
  const now = new Date();
  const stamp = Utilities.formatDate(now, tz, "dd/MM HH:mm");

  const cell = sh.getRange("N19");
  cell
    .setValue(`üïí Ultimo controllo: ${stamp}`)
    .setFontSize(10)              // ‚úÖ FONT 10
    .setFontStyle("italic")
    .setFontWeight("normal")
    .setFontColor("#666666")
    .setBackground("#ffffff")
    .setHorizontalAlignment("center")
    .setVerticalAlignment("middle");
}

function _hcUpdateCounters_(hadInterventions) {
  const props = PropertiesService.getDocumentProperties();

  const tz = Session.getScriptTimeZone();
  const todayKey = Utilities.formatDate(new Date(), tz, "yyyy-MM-dd");

  if (props.getProperty("HC_LAST_DAY") !== todayKey) {
    props.setProperty("HC_LAST_DAY", todayKey);
    props.setProperty("HC_TODAY", "0");
  }

  let today = Number(props.getProperty("HC_TODAY") || 0);
  let total = Number(props.getProperty("HC_TOTAL") || 0);

  if (hadInterventions) {
    today++;
    total++;
    props.setProperty("HC_TODAY", String(today));
    props.setProperty("HC_TOTAL", String(total));
  }

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sh = ss.getSheetByName("Settimana Attiva");
  if (!sh) return;

  const cell = sh.getRange("N20");
  cell
    .setValue(`üìä Interventi oggi: ${today} | Totale: ${total}`)
    .setFontSize(10)              // ‚úÖ FONT 10
    .setFontStyle("italic")
    .setFontWeight("normal")
    .setFontColor("#666666")
    .setBackground("#f3f3f3")
    .setHorizontalAlignment("center")
    .setVerticalAlignment("middle");
}

/****************************************************
 * ONOPEN ROBUSTO: menu subito + healthcheck differito
 ****************************************************/

function onOpen(e) {
  try { _bannerArchiviazioneAggiorna_(); } catch (e) {}
  // 1) Menu SEMPRE per primi
  try { BUILD_MENUS_(); } catch (err) {}

  // 2) Pianifica healthcheck differito (non blocca i menu)
  try { _SCHEDULE_HEALTHCHECK_AFTER_OPEN_(); } catch (err) {}
}

/**
 * Crea un trigger "usa e getta" che esegue il healthcheck dopo ~45s.
 * Evita duplicati con una property.
 */
function _SCHEDULE_HEALTHCHECK_AFTER_OPEN_() {
  const props = PropertiesService.getDocumentProperties();
  const key = "HC_DEFERRED_PENDING";
  if (props.getProperty(key) === "1") return; // gi√† pianificato

  // segna pending
  props.setProperty(key, "1");

  // crea trigger una tantum tra 45 secondi
  ScriptApp.newTrigger("_RUN_HEALTHCHECK_DEFERRED_")
    .timeBased()
    .after(45 * 1000)
    .create();
}

/**
 * Esegue healthcheck e poi:
 * - ripristina UI protette
 * - ripara N18/checkbox se necessario
 * - rimuove il trigger che l‚Äôha chiamata
 * - toglie la flag pending
 */
function _RUN_HEALTHCHECK_DEFERRED_() {
  const props = PropertiesService.getDocumentProperties();
  const key = "HC_DEFERRED_PENDING";

  try {
    // Healthcheck principale
    try { HEALTHCHECK_VISIVO(); } catch (e) {}

    // Ripristini UI colonna N
    try { UI_RIPRISTINA_CELLE_N_PROTETTE_(); } catch (e) {}

    // Ripara validazioni checkbox (N18 + tabella) se si sono sporcate
    try { RIPARA_VALIDAZIONI_CHECKBOX_HARD_(); } catch (e) {}

  } finally {
    // clear pending
    try { props.deleteProperty(key); } catch (e) {}

    // autodistrugge i trigger di questa funzione (cos√¨ non si accumulano)
    try {
      const all = ScriptApp.getProjectTriggers();
      for (const t of all) {
        if (t.getHandlerFunction && t.getHandlerFunction() === "_RUN_HEALTHCHECK_DEFERRED_") {
          ScriptApp.deleteTrigger(t);
        }
      }
    } catch (e) {}
  }
}

/****************************************************
 * RIPARAZIONE HARD VALIDAZIONI CHECKBOX
 * - Risolve "Invalid: violates validation rule" su N18
 * - Se per errore la validazione checkbox √® finita in L3 (o altrove),
 *   pulisce A3:L20 e ricostruisce le checkbox coerenti ai nomi.
 ****************************************************/
function RIPARA_VALIDAZIONI_CHECKBOX_HARD_() {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheets = ["Settimana Attiva", "Prossima settimana"];

  for (const name of sheets) {
    const sh = ss.getSheetByName(name);
    if (!sh) continue;

    // 1) N18: deve essere SOLO checkbox, senza validazioni "strane"
    try {
      const c = sh.getRange("N18");
      c.clearContent();
      c.clearDataValidations();
      c.insertCheckboxes();
      c.setValue(false);
      c.setHorizontalAlignment("center").setVerticalAlignment("middle");
    } catch (e) {}

    // 2) Tabella A3:L20: se una checkbox-validation √® finita in celle sbagliate (es. L3),
    //    puliamo tutte le data validations e ricostruiamo SOLO le checkbox corrette.
    try {
      sh.getRange("A3:L20").clearDataValidations();
      // ricostruisce checkbox e lascia vuote dove nome vuoto
      if (typeof MINI_FIX_FORMAT_TAB_FORNITORI_ === "function") {
        // la tua funzione agisce su entrambe: ok, ma qui siamo gi√† nel loop.
        // Se preferisci, commenta la riga sotto e lascia solo il rebuild manuale.
        MINI_FIX_FORMAT_TAB_FORNITORI_();
      } else {
        _REBUILD_CHECKBOXES_FROM_NAMES_(sh);
      }
    } catch (e) {}
  }
}

/**
 * Fallback se MINI_FIX_FORMAT_TAB_FORNITORI_ non esiste:
 * ricostruisce le checkbox in B/D/F/H/J/L in base ai nomi A/C/E/G/I/K.
 */
function _REBUILD_CHECKBOXES_FROM_NAMES_(sh) {
  const COL_NOMI = [1, 3, 5, 7, 9, 11];
  const COL_CK   = [2, 4, 6, 8, 10, 12];
  const START_ROW = 3;
  const NUM_ROWS = 18; // 3..20

  for (let i = 0; i < COL_NOMI.length; i++) {
    const colNome = COL_NOMI[i];
    const colCk = COL_CK[i];

    const nomi = sh.getRange(START_ROW, colNome, NUM_ROWS, 1).getValues();
    const ckRange = sh.getRange(START_ROW, colCk, NUM_ROWS, 1);
    const ckVals = ckRange.getValues();

    for (let r = 0; r < NUM_ROWS; r++) {
      const rawNome = nomi[r][0];
      const nomeTxt = String(rawNome ?? "").replace(/\u00A0/g, " ").trim();
      const cellCk = sh.getRange(START_ROW + r, colCk);

      if (!nomeTxt) {
        cellCk.clearContent();
        cellCk.clearDataValidations();
        continue;
      }

      cellCk.clearDataValidations();
      cellCk.insertCheckboxes();

      if (typeof _isNoPartenza_ === "function" && _isNoPartenza_(rawNome)) {
        cellCk.setValue(false);
      } else {
        cellCk.setValue(ckVals[r][0] === true);
      }
    }
  }
}
